// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  CONSUMER
  RIDER
  TRUCK_DRIVER
  WASTE_DRIVER
  ADMIN
}

enum KycStatus {
  NOT_SUBMITTED
  PENDING
  APPROVED
  REJECTED
}

enum AvailabilityStatus {
  OFFLINE
  AVAILABLE
  BUSY
}

model User {
  id           String @id @default(cuid())
  firstName    String
  lastName     String
  email        String @unique
  phone        String @unique
  passwordHash String

  role      UserRole  @default(CONSUMER)
  kycStatus KycStatus @default(NOT_SUBMITTED)

  isActive    Boolean   @default(true)
  isOnline    Boolean   @default(false)

   // âœ… NEW: availability state for dispatch acceptance
  availabilityStatus AvailabilityStatus @default(OFFLINE)

  // âœ… NEW: capacity for concurrent active orders (MVP=1, can increase later)
  maxActiveOrders Int @default(1)
  lastLoginAt DateTime?

  lastLat               Float?
  lastLng               Float?
  lastLocationUpdatedAt DateTime?
  walletBalance         Decimal   @default(0.0) @db.Decimal(12, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  refreshTokens       RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  kycProfile          KycProfile?

  customerOrders     Order[]             @relation("CustomerOrders")
  driverOrders       Order[]             @relation("DriverOrders")
  walletTransactions WalletTransaction[]
  withdrawals        Withdrawal[]

  @@index([role])
  @@index([kycStatus])
}

model RefreshToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String
  expiresAt DateTime
  revokedAt DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

enum PremblyStatus {
  NOT_STARTED
  VERIFIED
  FAILED
}

model KycProfile {
  id     String    @id @default(cuid())
  userId String    @unique
  status KycStatus @default(NOT_SUBMITTED)

  // ===== Existing Rider fields (keep for now) =====
  nin             String?
  motorcycleType  String?
  motorcycleMake  String?
  motorcycleModel String?
  motorcycleYear  Int?
  motorcyclePlate String?

  // ===== Existing Driver fields (keep for now) =====
  driversLicenseNumber String?
  driverLicenseDob     String?  // YYYY-MM-DD for Prembly driver's license verification
  vehicleMake          String?
  vehicleModel         String?
  vehicleYear          Int?
  vehiclePlate         String?

  // ===== Existing Document URLs (keep for now) =====
  ninDocUrl            String?
  motorcycleRegDocUrl  String?
  driversLicenseDocUrl String?
  vehicleRegDocUrl     String?

  // ===== NEW: Additional fields requested by client =====
  // Shared/vehicle fields
  vehicleColor String?
  vin          String?
  vehicleTrim  String?
  bodyType     String?
  loadCapacity String?

  motorcycleColor String?

  // ===== NEW: Upload URLs (Cloudinary) =====
  // Drivers license front/back
  driversLicenseFrontUrl String?
  driversLicenseBackUrl  String?

  // NIN front/back
  ninFrontUrl String?
  ninBackUrl  String?

  // Arrays of photos
  vehiclePhotos    Json? // array of urls
  motorcyclePhotos Json? // array of urls

  // Single photo urls
  driverInVehiclePhotoUrl   String?
  riderOnMotorcyclePhotoUrl String?

  // Compliance declarations
  hasValidVehiclePapers  Boolean?
  hasValidInsurance      Boolean?
  vehicleInGoodCondition Boolean?

  // ===== NEW: store client-shaped payloads =====
  riderKycJson   Json?
  vehicleKycJson Json?

  // Prembly tracking
  premblyStatus    PremblyStatus @default(NOT_STARTED)
  premblyReference String?
  premblyPayload   Json?
  premblyResponse  Json?

  reviewedById    String?
  reviewedAt      DateTime?
  rejectionReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum ServiceType {
  DISPATCH
  PARK_N_GO
  WASTE_PICKUP
  RIDE_BOOKING
}

enum OrderStatus {
  PENDING // created, not yet assigned
  ASSIGNED // assigned to a driver/rider (accepted or admin assigned)
  IN_PROGRESS // rider started movement
  COMPLETED
  CANCELLED
}

model Order {
  id          String      @id @default(cuid())
  orderCode   String      @unique
  serviceType ServiceType
  status      OrderStatus @default(PENDING)

  amount   Decimal @default(0.0) @db.Decimal(12, 2)
  currency String  @default("NGN")

  customerId String
  driverId   String?

  pickupAddress   String?
  deliveryAddress String?
  pickupLat       Float?
  pickupLng       Float?
  deliveryLat     Float?
  deliveryLng     Float?

  metadata Json? // ðŸ‘ˆ IMPORTANT (dispatch / parkngo / waste)

  acceptedAt  DateTime?
  completedAt DateTime?

  startedAt DateTime?

  tipAmount Decimal? @default(0.0)

  // optional: distance + eta if you want to store server-side
  distanceKm Float?
  etaMinutes Int?

  platformFee   Decimal @default(0.0) @db.Decimal(12, 2)
  driverEarning Decimal @default(0.0) @db.Decimal(12, 2)

  // âœ… payment tracking (Interswitch/Paystack)
  paymentStatus   String?   @default("pending") // pending | paid | failed | cancelled
  paymentReference String?
  paymentMethod   String?
  paidAt         DateTime?

  // âœ… payout tracking (admin credits wallet)
  isPayoutProcessed Boolean  @default(false)
  payoutProcessedAt DateTime?
  payoutProcessedBy String?  // admin userId
  payoutAmount      Decimal? @db.Decimal(12, 2) // how much credited (driverEarning + tip)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  customer   User   @relation("CustomerOrders", fields: [customerId], references: [id])
  driver     User?  @relation("DriverOrders", fields: [driverId], references: [id])
  paymentTransactions PaymentTransaction[]

  @@index([serviceType])
  @@index([status])
  @@index([createdAt])
  @@index([orderCode])
}

enum PaymentProvider {
  INTERSWITCH
  PAYSTACK
}

model PaymentMethod {
  id                 String   @id @default(cuid())
  name               String
  provider           PaymentProvider
  config             Json?
  isActive           Boolean  @default(true)
  supportedCurrencies String[] @default(["NGN"])
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  transactions PaymentTransaction[]
}

model PaymentTransaction {
  id                String   @id @default(cuid())
  orderId           String?
  paymentMethodId   String
  amount            Decimal  @db.Decimal(12, 2)
  currency          String   @default("NGN")
  providerReference String?
  status            String   @default("pending") // pending | success | failed
  metadata          Json?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  order        Order?        @relation(fields: [orderId], references: [id], onDelete: SetNull)
  paymentMethod PaymentMethod @relation(fields: [paymentMethodId], references: [id])

  @@index([orderId])
  @@index([providerReference])
  @@index([status])
}

model PaymentWebhookNotification {
  id              String   @id @default(cuid())
  provider        String   // interswitch | paystack
  paymentReference String?
  orderId         String?
  status          String   // success | failed
  payload         Json?
  rawBody         String?  @db.Text
  createdAt       DateTime @default(now())

  @@index([provider])
  @@index([paymentReference])
  @@index([orderId])
  @@index([createdAt])
}

enum DispatchPackageSize {
  SMALL
  MEDIUM
  LARGE
}

enum DispatchUrgency {
  STANDARD
  EXPRESS
  SAME_DAY
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

enum WalletTxType {
  CREDIT
  DEBIT
}

model WalletTransaction {
  id            String       @id @default(cuid())
  userId        String
  type          WalletTxType
  amount        Decimal      @db.Decimal(12, 2)
  balanceBefore Decimal      @db.Decimal(12, 2)
  balanceAfter  Decimal      @db.Decimal(12, 2)

  // link earning to order (so one order credits once)
  orderId String? @unique
  withdrawalId  String? @unique
  note    String?

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
  PAID
}

model Withdrawal {
  id     String           @id @default(cuid())
  userId String
  amount Decimal          @db.Decimal(12, 2)
  status WithdrawalStatus @default(PENDING)

  // payout destination (simple v1)
  bankName      String?
  accountName   String?
  accountNumber String?

  // admin review
  reviewedById    String?
  reviewedAt      DateTime?
  rejectionReason String?

  // payment tracking (optional)
  paidAt     DateTime?
  paymentRef String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}
